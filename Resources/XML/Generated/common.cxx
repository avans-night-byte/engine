// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "common.hxx"

namespace Common
{
  // baseResources
  // 

  const baseResources::default_type& baseResources::
  default_ () const
  {
    return this->default__.get ();
  }

  baseResources::default_type& baseResources::
  default_ ()
  {
    return this->default__.get ();
  }

  void baseResources::
  default_ (const default_type& x)
  {
    this->default__.set (x);
  }

  void baseResources::
  default_ (::std::unique_ptr< default_type > x)
  {
    this->default__.set (std::move (x));
  }


  // alpha
  // 


  // preloadResources
  // 

  const preloadResources::resource_sequence& preloadResources::
  resource () const
  {
    return this->resource_;
  }

  preloadResources::resource_sequence& preloadResources::
  resource ()
  {
    return this->resource_;
  }

  void preloadResources::
  resource (const resource_sequence& s)
  {
    this->resource_ = s;
  }


  // resources
  // 


  // events
  // 

  const events::onEnter_optional& events::
  onEnter () const
  {
    return this->onEnter_;
  }

  events::onEnter_optional& events::
  onEnter ()
  {
    return this->onEnter_;
  }

  void events::
  onEnter (const onEnter_type& x)
  {
    this->onEnter_.set (x);
  }

  void events::
  onEnter (const onEnter_optional& x)
  {
    this->onEnter_ = x;
  }

  void events::
  onEnter (::std::unique_ptr< onEnter_type > x)
  {
    this->onEnter_.set (std::move (x));
  }

  const events::onLeave_optional& events::
  onLeave () const
  {
    return this->onLeave_;
  }

  events::onLeave_optional& events::
  onLeave ()
  {
    return this->onLeave_;
  }

  void events::
  onLeave (const onLeave_type& x)
  {
    this->onLeave_.set (x);
  }

  void events::
  onLeave (const onLeave_optional& x)
  {
    this->onLeave_ = x;
  }

  void events::
  onLeave (::std::unique_ptr< onLeave_type > x)
  {
    this->onLeave_.set (std::move (x));
  }

  const events::onAttacked_optional& events::
  onAttacked () const
  {
    return this->onAttacked_;
  }

  events::onAttacked_optional& events::
  onAttacked ()
  {
    return this->onAttacked_;
  }

  void events::
  onAttacked (const onAttacked_type& x)
  {
    this->onAttacked_.set (x);
  }

  void events::
  onAttacked (const onAttacked_optional& x)
  {
    this->onAttacked_ = x;
  }

  void events::
  onAttacked (::std::unique_ptr< onAttacked_type > x)
  {
    this->onAttacked_.set (std::move (x));
  }

  const events::onDestroyed_optional& events::
  onDestroyed () const
  {
    return this->onDestroyed_;
  }

  events::onDestroyed_optional& events::
  onDestroyed ()
  {
    return this->onDestroyed_;
  }

  void events::
  onDestroyed (const onDestroyed_type& x)
  {
    this->onDestroyed_.set (x);
  }

  void events::
  onDestroyed (const onDestroyed_optional& x)
  {
    this->onDestroyed_ = x;
  }

  void events::
  onDestroyed (::std::unique_ptr< onDestroyed_type > x)
  {
    this->onDestroyed_.set (std::move (x));
  }

  const events::onAttack_optional& events::
  onAttack () const
  {
    return this->onAttack_;
  }

  events::onAttack_optional& events::
  onAttack ()
  {
    return this->onAttack_;
  }

  void events::
  onAttack (const onAttack_type& x)
  {
    this->onAttack_.set (x);
  }

  void events::
  onAttack (const onAttack_optional& x)
  {
    this->onAttack_ = x;
  }

  void events::
  onAttack (::std::unique_ptr< onAttack_type > x)
  {
    this->onAttack_.set (std::move (x));
  }

  const events::onClick_optional& events::
  onClick () const
  {
    return this->onClick_;
  }

  events::onClick_optional& events::
  onClick ()
  {
    return this->onClick_;
  }

  void events::
  onClick (const onClick_type& x)
  {
    this->onClick_.set (x);
  }

  void events::
  onClick (const onClick_optional& x)
  {
    this->onClick_ = x;
  }

  void events::
  onClick (::std::unique_ptr< onClick_type > x)
  {
    this->onClick_.set (std::move (x));
  }


  // position
  // 

  const position::x_type& position::
  x () const
  {
    return this->x_.get ();
  }

  position::x_type& position::
  x ()
  {
    return this->x_.get ();
  }

  void position::
  x (const x_type& x)
  {
    this->x_.set (x);
  }

  const position::y_type& position::
  y () const
  {
    return this->y_.get ();
  }

  position::y_type& position::
  y ()
  {
    return this->y_.get ();
  }

  void position::
  y (const y_type& x)
  {
    this->y_.set (x);
  }


  // size
  // 

  const size::width_type& size::
  width () const
  {
    return this->width_.get ();
  }

  size::width_type& size::
  width ()
  {
    return this->width_.get ();
  }

  void size::
  width (const width_type& x)
  {
    this->width_.set (x);
  }

  const size::height_type& size::
  height () const
  {
    return this->height_.get ();
  }

  size::height_type& size::
  height ()
  {
    return this->height_.get ();
  }

  void size::
  height (const height_type& x)
  {
    this->height_.set (x);
  }


  // color
  // 

  const color::hex_type& color::
  hex () const
  {
    return this->hex_.get ();
  }

  color::hex_type& color::
  hex ()
  {
    return this->hex_.get ();
  }

  void color::
  hex (const hex_type& x)
  {
    this->hex_.set (x);
  }

  void color::
  hex (::std::unique_ptr< hex_type > x)
  {
    this->hex_.set (std::move (x));
  }

  const color::alpha_type& color::
  alpha () const
  {
    return this->alpha_.get ();
  }

  color::alpha_type& color::
  alpha ()
  {
    return this->alpha_.get ();
  }

  void color::
  alpha (const alpha_type& x)
  {
    this->alpha_.set (x);
  }

  void color::
  alpha (::std::unique_ptr< alpha_type > x)
  {
    this->alpha_.set (std::move (x));
  }


  // font
  // 

  const font::family_type& font::
  family () const
  {
    return this->family_.get ();
  }

  font::family_type& font::
  family ()
  {
    return this->family_.get ();
  }

  void font::
  family (const family_type& x)
  {
    this->family_.set (x);
  }

  void font::
  family (::std::unique_ptr< family_type > x)
  {
    this->family_.set (std::move (x));
  }

  const font::weight_type& font::
  weight () const
  {
    return this->weight_.get ();
  }

  font::weight_type& font::
  weight ()
  {
    return this->weight_.get ();
  }

  void font::
  weight (const weight_type& x)
  {
    this->weight_.set (x);
  }

  void font::
  weight (::std::unique_ptr< weight_type > x)
  {
    this->weight_.set (std::move (x));
  }

  const font::size_type& font::
  size () const
  {
    return this->size_.get ();
  }

  font::size_type& font::
  size ()
  {
    return this->size_.get ();
  }

  void font::
  size (const size_type& x)
  {
    this->size_.set (x);
  }


  // text_type
  // 

  const text_type::dynamic_optional& text_type::
  dynamic () const
  {
    return this->dynamic_;
  }

  text_type::dynamic_optional& text_type::
  dynamic ()
  {
    return this->dynamic_;
  }

  void text_type::
  dynamic (const dynamic_type& x)
  {
    this->dynamic_.set (x);
  }

  void text_type::
  dynamic (const dynamic_optional& x)
  {
    this->dynamic_ = x;
  }

  void text_type::
  dynamic (::std::unique_ptr< dynamic_type > x)
  {
    this->dynamic_.set (std::move (x));
  }

  const text_type::static_optional& text_type::
  static_ () const
  {
    return this->static__;
  }

  text_type::static_optional& text_type::
  static_ ()
  {
    return this->static__;
  }

  void text_type::
  static_ (const static_type& x)
  {
    this->static__.set (x);
  }

  void text_type::
  static_ (const static_optional& x)
  {
    this->static__ = x;
  }

  void text_type::
  static_ (::std::unique_ptr< static_type > x)
  {
    this->static__.set (std::move (x));
  }


  // onEnter
  // 

  const onEnter::playSound_optional& onEnter::
  playSound () const
  {
    return this->playSound_;
  }

  onEnter::playSound_optional& onEnter::
  playSound ()
  {
    return this->playSound_;
  }

  void onEnter::
  playSound (const playSound_type& x)
  {
    this->playSound_.set (x);
  }

  void onEnter::
  playSound (const playSound_optional& x)
  {
    this->playSound_ = x;
  }

  void onEnter::
  playSound (::std::unique_ptr< playSound_type > x)
  {
    this->playSound_.set (std::move (x));
  }

  const onEnter::loadAction_optional& onEnter::
  loadAction () const
  {
    return this->loadAction_;
  }

  onEnter::loadAction_optional& onEnter::
  loadAction ()
  {
    return this->loadAction_;
  }

  void onEnter::
  loadAction (const loadAction_type& x)
  {
    this->loadAction_.set (x);
  }

  void onEnter::
  loadAction (const loadAction_optional& x)
  {
    this->loadAction_ = x;
  }

  void onEnter::
  loadAction (::std::unique_ptr< loadAction_type > x)
  {
    this->loadAction_.set (std::move (x));
  }


  // onLeave
  // 

  const onLeave::playSound_optional& onLeave::
  playSound () const
  {
    return this->playSound_;
  }

  onLeave::playSound_optional& onLeave::
  playSound ()
  {
    return this->playSound_;
  }

  void onLeave::
  playSound (const playSound_type& x)
  {
    this->playSound_.set (x);
  }

  void onLeave::
  playSound (const playSound_optional& x)
  {
    this->playSound_ = x;
  }

  void onLeave::
  playSound (::std::unique_ptr< playSound_type > x)
  {
    this->playSound_.set (std::move (x));
  }

  const onLeave::loadAction_optional& onLeave::
  loadAction () const
  {
    return this->loadAction_;
  }

  onLeave::loadAction_optional& onLeave::
  loadAction ()
  {
    return this->loadAction_;
  }

  void onLeave::
  loadAction (const loadAction_type& x)
  {
    this->loadAction_.set (x);
  }

  void onLeave::
  loadAction (const loadAction_optional& x)
  {
    this->loadAction_ = x;
  }

  void onLeave::
  loadAction (::std::unique_ptr< loadAction_type > x)
  {
    this->loadAction_.set (std::move (x));
  }


  // onAttacked
  // 

  const onAttacked::playSound_optional& onAttacked::
  playSound () const
  {
    return this->playSound_;
  }

  onAttacked::playSound_optional& onAttacked::
  playSound ()
  {
    return this->playSound_;
  }

  void onAttacked::
  playSound (const playSound_type& x)
  {
    this->playSound_.set (x);
  }

  void onAttacked::
  playSound (const playSound_optional& x)
  {
    this->playSound_ = x;
  }

  void onAttacked::
  playSound (::std::unique_ptr< playSound_type > x)
  {
    this->playSound_.set (std::move (x));
  }

  const onAttacked::loadAction_optional& onAttacked::
  loadAction () const
  {
    return this->loadAction_;
  }

  onAttacked::loadAction_optional& onAttacked::
  loadAction ()
  {
    return this->loadAction_;
  }

  void onAttacked::
  loadAction (const loadAction_type& x)
  {
    this->loadAction_.set (x);
  }

  void onAttacked::
  loadAction (const loadAction_optional& x)
  {
    this->loadAction_ = x;
  }

  void onAttacked::
  loadAction (::std::unique_ptr< loadAction_type > x)
  {
    this->loadAction_.set (std::move (x));
  }


  // onDestroyed
  // 

  const onDestroyed::playSound_optional& onDestroyed::
  playSound () const
  {
    return this->playSound_;
  }

  onDestroyed::playSound_optional& onDestroyed::
  playSound ()
  {
    return this->playSound_;
  }

  void onDestroyed::
  playSound (const playSound_type& x)
  {
    this->playSound_.set (x);
  }

  void onDestroyed::
  playSound (const playSound_optional& x)
  {
    this->playSound_ = x;
  }

  void onDestroyed::
  playSound (::std::unique_ptr< playSound_type > x)
  {
    this->playSound_.set (std::move (x));
  }

  const onDestroyed::loadAction_optional& onDestroyed::
  loadAction () const
  {
    return this->loadAction_;
  }

  onDestroyed::loadAction_optional& onDestroyed::
  loadAction ()
  {
    return this->loadAction_;
  }

  void onDestroyed::
  loadAction (const loadAction_type& x)
  {
    this->loadAction_.set (x);
  }

  void onDestroyed::
  loadAction (const loadAction_optional& x)
  {
    this->loadAction_ = x;
  }

  void onDestroyed::
  loadAction (::std::unique_ptr< loadAction_type > x)
  {
    this->loadAction_.set (std::move (x));
  }


  // onAttack
  // 

  const onAttack::playSound_optional& onAttack::
  playSound () const
  {
    return this->playSound_;
  }

  onAttack::playSound_optional& onAttack::
  playSound ()
  {
    return this->playSound_;
  }

  void onAttack::
  playSound (const playSound_type& x)
  {
    this->playSound_.set (x);
  }

  void onAttack::
  playSound (const playSound_optional& x)
  {
    this->playSound_ = x;
  }

  void onAttack::
  playSound (::std::unique_ptr< playSound_type > x)
  {
    this->playSound_.set (std::move (x));
  }

  const onAttack::loadAction_optional& onAttack::
  loadAction () const
  {
    return this->loadAction_;
  }

  onAttack::loadAction_optional& onAttack::
  loadAction ()
  {
    return this->loadAction_;
  }

  void onAttack::
  loadAction (const loadAction_type& x)
  {
    this->loadAction_.set (x);
  }

  void onAttack::
  loadAction (const loadAction_optional& x)
  {
    this->loadAction_ = x;
  }

  void onAttack::
  loadAction (::std::unique_ptr< loadAction_type > x)
  {
    this->loadAction_.set (std::move (x));
  }


  // onClick
  // 

  const onClick::playSound_optional& onClick::
  playSound () const
  {
    return this->playSound_;
  }

  onClick::playSound_optional& onClick::
  playSound ()
  {
    return this->playSound_;
  }

  void onClick::
  playSound (const playSound_type& x)
  {
    this->playSound_.set (x);
  }

  void onClick::
  playSound (const playSound_optional& x)
  {
    this->playSound_ = x;
  }

  void onClick::
  playSound (::std::unique_ptr< playSound_type > x)
  {
    this->playSound_.set (std::move (x));
  }

  const onClick::loadScene_optional& onClick::
  loadScene () const
  {
    return this->loadScene_;
  }

  onClick::loadScene_optional& onClick::
  loadScene ()
  {
    return this->loadScene_;
  }

  void onClick::
  loadScene (const loadScene_type& x)
  {
    this->loadScene_.set (x);
  }

  void onClick::
  loadScene (const loadScene_optional& x)
  {
    this->loadScene_ = x;
  }

  void onClick::
  loadScene (::std::unique_ptr< loadScene_type > x)
  {
    this->loadScene_.set (std::move (x));
  }

  const onClick::custom_optional& onClick::
  custom () const
  {
    return this->custom_;
  }

  onClick::custom_optional& onClick::
  custom ()
  {
    return this->custom_;
  }

  void onClick::
  custom (const custom_type& x)
  {
    this->custom_.set (x);
  }

  void onClick::
  custom (const custom_optional& x)
  {
    this->custom_ = x;
  }

  void onClick::
  custom (::std::unique_ptr< custom_type > x)
  {
    this->custom_.set (std::move (x));
  }

  const onClick::loadURL_optional& onClick::
  loadURL () const
  {
    return this->loadURL_;
  }

  onClick::loadURL_optional& onClick::
  loadURL ()
  {
    return this->loadURL_;
  }

  void onClick::
  loadURL (const loadURL_type& x)
  {
    this->loadURL_.set (x);
  }

  void onClick::
  loadURL (const loadURL_optional& x)
  {
    this->loadURL_ = x;
  }

  void onClick::
  loadURL (::std::unique_ptr< loadURL_type > x)
  {
    this->loadURL_.set (std::move (x));
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace Common
{
  // baseResources
  //

  baseResources::
  baseResources (const default_type& default_)
  : ::xml_schema::type (),
    default__ (default_, this)
  {
  }

  baseResources::
  baseResources (const baseResources& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    default__ (x.default__, f, this)
  {
  }

  baseResources::
  baseResources (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    default__ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void baseResources::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // default
      //
      if (n.name () == "default" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< default_type > r (
          default_traits::create (i, f, this));

        if (!default__.present ())
        {
          this->default__.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!default__.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "default",
        "");
    }
  }

  baseResources* baseResources::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class baseResources (*this, f, c);
  }

  baseResources& baseResources::
  operator= (const baseResources& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->default__ = x.default__;
    }

    return *this;
  }

  baseResources::
  ~baseResources ()
  {
  }

  // alpha
  //

  alpha::
  alpha (const ::xml_schema::float_& _xsd_float__base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base)
  {
  }

  alpha::
  alpha (const alpha& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  alpha::
  alpha (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  alpha::
  alpha (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  alpha::
  alpha (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  alpha* alpha::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class alpha (*this, f, c);
  }

  alpha::
  ~alpha ()
  {
  }

  // preloadResources
  //

  preloadResources::
  preloadResources ()
  : ::xml_schema::type (),
    resource_ (this)
  {
  }

  preloadResources::
  preloadResources (const preloadResources& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    resource_ (x.resource_, f, this)
  {
  }

  preloadResources::
  preloadResources (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    resource_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void preloadResources::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // resource
      //
      if (n.name () == "resource" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< resource_type > r (
          resource_traits::create (i, f, this));

        this->resource_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  preloadResources* preloadResources::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class preloadResources (*this, f, c);
  }

  preloadResources& preloadResources::
  operator= (const preloadResources& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->resource_ = x.resource_;
    }

    return *this;
  }

  preloadResources::
  ~preloadResources ()
  {
  }

  // resources
  //

  resources::
  resources (const default_type& default_)
  : ::Common::baseResources (default_)
  {
  }

  resources::
  resources (const resources& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::Common::baseResources (x, f, c)
  {
  }

  resources::
  resources (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::Common::baseResources (e, f, c)
  {
  }

  resources* resources::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class resources (*this, f, c);
  }

  resources::
  ~resources ()
  {
  }

  // events
  //

  events::
  events ()
  : ::xml_schema::type (),
    onEnter_ (this),
    onLeave_ (this),
    onAttacked_ (this),
    onDestroyed_ (this),
    onAttack_ (this),
    onClick_ (this)
  {
  }

  events::
  events (const events& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    onEnter_ (x.onEnter_, f, this),
    onLeave_ (x.onLeave_, f, this),
    onAttacked_ (x.onAttacked_, f, this),
    onDestroyed_ (x.onDestroyed_, f, this),
    onAttack_ (x.onAttack_, f, this),
    onClick_ (x.onClick_, f, this)
  {
  }

  events::
  events (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    onEnter_ (this),
    onLeave_ (this),
    onAttacked_ (this),
    onDestroyed_ (this),
    onAttack_ (this),
    onClick_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void events::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // onEnter
      //
      if (n.name () == "onEnter" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< onEnter_type > r (
          onEnter_traits::create (i, f, this));

        if (!this->onEnter_)
        {
          this->onEnter_.set (::std::move (r));
          continue;
        }
      }

      // onLeave
      //
      if (n.name () == "onLeave" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< onLeave_type > r (
          onLeave_traits::create (i, f, this));

        if (!this->onLeave_)
        {
          this->onLeave_.set (::std::move (r));
          continue;
        }
      }

      // onAttacked
      //
      if (n.name () == "onAttacked" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< onAttacked_type > r (
          onAttacked_traits::create (i, f, this));

        if (!this->onAttacked_)
        {
          this->onAttacked_.set (::std::move (r));
          continue;
        }
      }

      // onDestroyed
      //
      if (n.name () == "onDestroyed" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< onDestroyed_type > r (
          onDestroyed_traits::create (i, f, this));

        if (!this->onDestroyed_)
        {
          this->onDestroyed_.set (::std::move (r));
          continue;
        }
      }

      // onAttack
      //
      if (n.name () == "onAttack" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< onAttack_type > r (
          onAttack_traits::create (i, f, this));

        if (!this->onAttack_)
        {
          this->onAttack_.set (::std::move (r));
          continue;
        }
      }

      // onClick
      //
      if (n.name () == "onClick" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< onClick_type > r (
          onClick_traits::create (i, f, this));

        if (!this->onClick_)
        {
          this->onClick_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  events* events::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class events (*this, f, c);
  }

  events& events::
  operator= (const events& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->onEnter_ = x.onEnter_;
      this->onLeave_ = x.onLeave_;
      this->onAttacked_ = x.onAttacked_;
      this->onDestroyed_ = x.onDestroyed_;
      this->onAttack_ = x.onAttack_;
      this->onClick_ = x.onClick_;
    }

    return *this;
  }

  events::
  ~events ()
  {
  }

  // position
  //

  position::
  position (const x_type& x,
            const y_type& y)
  : ::xml_schema::type (),
    x_ (x, this),
    y_ (y, this)
  {
  }

  position::
  position (const position& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this)
  {
  }

  position::
  position (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    x_ (this),
    y_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void position::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ ().empty ())
      {
        if (!x_.present ())
        {
          this->x_.set (x_traits::create (i, f, this));
          continue;
        }
      }

      // y
      //
      if (n.name () == "y" && n.namespace_ ().empty ())
      {
        if (!y_.present ())
        {
          this->y_.set (y_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "");
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "y",
        "");
    }
  }

  position* position::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class position (*this, f, c);
  }

  position& position::
  operator= (const position& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->x_ = x.x_;
      this->y_ = x.y_;
    }

    return *this;
  }

  position::
  ~position ()
  {
  }

  // size
  //

  size::
  size (const width_type& width,
        const height_type& height)
  : ::xml_schema::type (),
    width_ (width, this),
    height_ (height, this)
  {
  }

  size::
  size (const size& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    width_ (x.width_, f, this),
    height_ (x.height_, f, this)
  {
  }

  size::
  size (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    width_ (this),
    height_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void size::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // width
      //
      if (n.name () == "width" && n.namespace_ ().empty ())
      {
        if (!width_.present ())
        {
          this->width_.set (width_traits::create (i, f, this));
          continue;
        }
      }

      // height
      //
      if (n.name () == "height" && n.namespace_ ().empty ())
      {
        if (!height_.present ())
        {
          this->height_.set (height_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!width_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "width",
        "");
    }

    if (!height_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "height",
        "");
    }
  }

  size* size::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class size (*this, f, c);
  }

  size& size::
  operator= (const size& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->width_ = x.width_;
      this->height_ = x.height_;
    }

    return *this;
  }

  size::
  ~size ()
  {
  }

  // color
  //

  color::
  color (const hex_type& hex,
         const alpha_type& alpha)
  : ::xml_schema::type (),
    hex_ (hex, this),
    alpha_ (alpha, this)
  {
  }

  color::
  color (const color& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    hex_ (x.hex_, f, this),
    alpha_ (x.alpha_, f, this)
  {
  }

  color::
  color (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    hex_ (this),
    alpha_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void color::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // hex
      //
      if (n.name () == "hex" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< hex_type > r (
          hex_traits::create (i, f, this));

        if (!hex_.present ())
        {
          this->hex_.set (::std::move (r));
          continue;
        }
      }

      // alpha
      //
      if (n.name () == "alpha" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< alpha_type > r (
          alpha_traits::create (i, f, this));

        if (!alpha_.present ())
        {
          this->alpha_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!hex_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "hex",
        "");
    }

    if (!alpha_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "alpha",
        "");
    }
  }

  color* color::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class color (*this, f, c);
  }

  color& color::
  operator= (const color& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->hex_ = x.hex_;
      this->alpha_ = x.alpha_;
    }

    return *this;
  }

  color::
  ~color ()
  {
  }

  // font
  //

  font::
  font (const family_type& family,
        const weight_type& weight,
        const size_type& size)
  : ::xml_schema::type (),
    family_ (family, this),
    weight_ (weight, this),
    size_ (size, this)
  {
  }

  font::
  font (const font& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    family_ (x.family_, f, this),
    weight_ (x.weight_, f, this),
    size_ (x.size_, f, this)
  {
  }

  font::
  font (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    family_ (this),
    weight_ (this),
    size_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void font::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // family
      //
      if (n.name () == "family" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< family_type > r (
          family_traits::create (i, f, this));

        if (!family_.present ())
        {
          this->family_.set (::std::move (r));
          continue;
        }
      }

      // weight
      //
      if (n.name () == "weight" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< weight_type > r (
          weight_traits::create (i, f, this));

        if (!weight_.present ())
        {
          this->weight_.set (::std::move (r));
          continue;
        }
      }

      // size
      //
      if (n.name () == "size" && n.namespace_ ().empty ())
      {
        if (!size_.present ())
        {
          this->size_.set (size_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!family_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "family",
        "");
    }

    if (!weight_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "weight",
        "");
    }

    if (!size_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "size",
        "");
    }
  }

  font* font::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class font (*this, f, c);
  }

  font& font::
  operator= (const font& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->family_ = x.family_;
      this->weight_ = x.weight_;
      this->size_ = x.size_;
    }

    return *this;
  }

  font::
  ~font ()
  {
  }

  // text_type
  //

  text_type::
  text_type ()
  : ::xml_schema::type (),
    dynamic_ (this),
    static__ (this)
  {
  }

  text_type::
  text_type (const text_type& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    dynamic_ (x.dynamic_, f, this),
    static__ (x.static__, f, this)
  {
  }

  text_type::
  text_type (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    dynamic_ (this),
    static__ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void text_type::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // dynamic
      //
      if (n.name () == "dynamic" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< dynamic_type > r (
          dynamic_traits::create (i, f, this));

        if (!this->dynamic_)
        {
          this->dynamic_.set (::std::move (r));
          continue;
        }
      }

      // static
      //
      if (n.name () == "static" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< static_type > r (
          static_traits::create (i, f, this));

        if (!this->static__)
        {
          this->static__.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  text_type* text_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class text_type (*this, f, c);
  }

  text_type& text_type::
  operator= (const text_type& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->dynamic_ = x.dynamic_;
      this->static__ = x.static__;
    }

    return *this;
  }

  text_type::
  ~text_type ()
  {
  }

  // onEnter
  //

  onEnter::
  onEnter ()
  : ::xml_schema::type (),
    playSound_ (this),
    loadAction_ (this)
  {
  }

  onEnter::
  onEnter (const onEnter& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    playSound_ (x.playSound_, f, this),
    loadAction_ (x.loadAction_, f, this)
  {
  }

  onEnter::
  onEnter (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    playSound_ (this),
    loadAction_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void onEnter::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // playSound
      //
      if (n.name () == "playSound" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< playSound_type > r (
          playSound_traits::create (i, f, this));

        if (!this->playSound_)
        {
          this->playSound_.set (::std::move (r));
          continue;
        }
      }

      // loadAction
      //
      if (n.name () == "loadAction" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< loadAction_type > r (
          loadAction_traits::create (i, f, this));

        if (!this->loadAction_)
        {
          this->loadAction_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  onEnter* onEnter::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class onEnter (*this, f, c);
  }

  onEnter& onEnter::
  operator= (const onEnter& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->playSound_ = x.playSound_;
      this->loadAction_ = x.loadAction_;
    }

    return *this;
  }

  onEnter::
  ~onEnter ()
  {
  }

  // onLeave
  //

  onLeave::
  onLeave ()
  : ::xml_schema::type (),
    playSound_ (this),
    loadAction_ (this)
  {
  }

  onLeave::
  onLeave (const onLeave& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    playSound_ (x.playSound_, f, this),
    loadAction_ (x.loadAction_, f, this)
  {
  }

  onLeave::
  onLeave (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    playSound_ (this),
    loadAction_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void onLeave::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // playSound
      //
      if (n.name () == "playSound" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< playSound_type > r (
          playSound_traits::create (i, f, this));

        if (!this->playSound_)
        {
          this->playSound_.set (::std::move (r));
          continue;
        }
      }

      // loadAction
      //
      if (n.name () == "loadAction" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< loadAction_type > r (
          loadAction_traits::create (i, f, this));

        if (!this->loadAction_)
        {
          this->loadAction_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  onLeave* onLeave::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class onLeave (*this, f, c);
  }

  onLeave& onLeave::
  operator= (const onLeave& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->playSound_ = x.playSound_;
      this->loadAction_ = x.loadAction_;
    }

    return *this;
  }

  onLeave::
  ~onLeave ()
  {
  }

  // onAttacked
  //

  onAttacked::
  onAttacked ()
  : ::xml_schema::type (),
    playSound_ (this),
    loadAction_ (this)
  {
  }

  onAttacked::
  onAttacked (const onAttacked& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    playSound_ (x.playSound_, f, this),
    loadAction_ (x.loadAction_, f, this)
  {
  }

  onAttacked::
  onAttacked (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    playSound_ (this),
    loadAction_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void onAttacked::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // playSound
      //
      if (n.name () == "playSound" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< playSound_type > r (
          playSound_traits::create (i, f, this));

        if (!this->playSound_)
        {
          this->playSound_.set (::std::move (r));
          continue;
        }
      }

      // loadAction
      //
      if (n.name () == "loadAction" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< loadAction_type > r (
          loadAction_traits::create (i, f, this));

        if (!this->loadAction_)
        {
          this->loadAction_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  onAttacked* onAttacked::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class onAttacked (*this, f, c);
  }

  onAttacked& onAttacked::
  operator= (const onAttacked& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->playSound_ = x.playSound_;
      this->loadAction_ = x.loadAction_;
    }

    return *this;
  }

  onAttacked::
  ~onAttacked ()
  {
  }

  // onDestroyed
  //

  onDestroyed::
  onDestroyed ()
  : ::xml_schema::type (),
    playSound_ (this),
    loadAction_ (this)
  {
  }

  onDestroyed::
  onDestroyed (const onDestroyed& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    playSound_ (x.playSound_, f, this),
    loadAction_ (x.loadAction_, f, this)
  {
  }

  onDestroyed::
  onDestroyed (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    playSound_ (this),
    loadAction_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void onDestroyed::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // playSound
      //
      if (n.name () == "playSound" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< playSound_type > r (
          playSound_traits::create (i, f, this));

        if (!this->playSound_)
        {
          this->playSound_.set (::std::move (r));
          continue;
        }
      }

      // loadAction
      //
      if (n.name () == "loadAction" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< loadAction_type > r (
          loadAction_traits::create (i, f, this));

        if (!this->loadAction_)
        {
          this->loadAction_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  onDestroyed* onDestroyed::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class onDestroyed (*this, f, c);
  }

  onDestroyed& onDestroyed::
  operator= (const onDestroyed& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->playSound_ = x.playSound_;
      this->loadAction_ = x.loadAction_;
    }

    return *this;
  }

  onDestroyed::
  ~onDestroyed ()
  {
  }

  // onAttack
  //

  onAttack::
  onAttack ()
  : ::xml_schema::type (),
    playSound_ (this),
    loadAction_ (this)
  {
  }

  onAttack::
  onAttack (const onAttack& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    playSound_ (x.playSound_, f, this),
    loadAction_ (x.loadAction_, f, this)
  {
  }

  onAttack::
  onAttack (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    playSound_ (this),
    loadAction_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void onAttack::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // playSound
      //
      if (n.name () == "playSound" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< playSound_type > r (
          playSound_traits::create (i, f, this));

        if (!this->playSound_)
        {
          this->playSound_.set (::std::move (r));
          continue;
        }
      }

      // loadAction
      //
      if (n.name () == "loadAction" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< loadAction_type > r (
          loadAction_traits::create (i, f, this));

        if (!this->loadAction_)
        {
          this->loadAction_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  onAttack* onAttack::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class onAttack (*this, f, c);
  }

  onAttack& onAttack::
  operator= (const onAttack& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->playSound_ = x.playSound_;
      this->loadAction_ = x.loadAction_;
    }

    return *this;
  }

  onAttack::
  ~onAttack ()
  {
  }

  // onClick
  //

  onClick::
  onClick ()
  : ::xml_schema::type (),
    playSound_ (this),
    loadScene_ (this),
    custom_ (this),
    loadURL_ (this)
  {
  }

  onClick::
  onClick (const onClick& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    playSound_ (x.playSound_, f, this),
    loadScene_ (x.loadScene_, f, this),
    custom_ (x.custom_, f, this),
    loadURL_ (x.loadURL_, f, this)
  {
  }

  onClick::
  onClick (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    playSound_ (this),
    loadScene_ (this),
    custom_ (this),
    loadURL_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void onClick::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // playSound
      //
      if (n.name () == "playSound" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< playSound_type > r (
          playSound_traits::create (i, f, this));

        if (!this->playSound_)
        {
          this->playSound_.set (::std::move (r));
          continue;
        }
      }

      // loadScene
      //
      if (n.name () == "loadScene" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< loadScene_type > r (
          loadScene_traits::create (i, f, this));

        if (!this->loadScene_)
        {
          this->loadScene_.set (::std::move (r));
          continue;
        }
      }

      // custom
      //
      if (n.name () == "custom" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< custom_type > r (
          custom_traits::create (i, f, this));

        if (!this->custom_)
        {
          this->custom_.set (::std::move (r));
          continue;
        }
      }

      // loadURL
      //
      if (n.name () == "loadURL" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< loadURL_type > r (
          loadURL_traits::create (i, f, this));

        if (!this->loadURL_)
        {
          this->loadURL_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  onClick* onClick::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class onClick (*this, f, c);
  }

  onClick& onClick::
  operator= (const onClick& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->playSound_ = x.playSound_;
      this->loadScene_ = x.loadScene_;
      this->custom_ = x.custom_;
      this->loadURL_ = x.loadURL_;
    }

    return *this;
  }

  onClick::
  ~onClick ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace Common
{
  ::std::unique_ptr< ::Common::preloadResources >
  preloadResources_ (const ::std::string& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::Common::preloadResources > (
      ::Common::preloadResources_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::preloadResources >
  preloadResources_ (const ::std::string& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Common::preloadResources > (
      ::Common::preloadResources_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::preloadResources >
  preloadResources_ (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Common::preloadResources > (
      ::Common::preloadResources_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::preloadResources >
  preloadResources_ (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::Common::preloadResources_ (isrc, f, p);
  }

  ::std::unique_ptr< ::Common::preloadResources >
  preloadResources_ (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::Common::preloadResources_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Common::preloadResources >
  preloadResources_ (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::Common::preloadResources_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Common::preloadResources >
  preloadResources_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::Common::preloadResources_ (isrc, f, p);
  }

  ::std::unique_ptr< ::Common::preloadResources >
  preloadResources_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::Common::preloadResources_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Common::preloadResources >
  preloadResources_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::Common::preloadResources_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Common::preloadResources >
  preloadResources_ (::xercesc::InputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::Common::preloadResources > (
      ::Common::preloadResources_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::preloadResources >
  preloadResources_ (::xercesc::InputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Common::preloadResources > (
      ::Common::preloadResources_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::preloadResources >
  preloadResources_ (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Common::preloadResources > (
      ::Common::preloadResources_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::preloadResources >
  preloadResources_ (const ::xercesc::DOMDocument& doc,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::Common::preloadResources > (
        ::Common::preloadResources_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "preloadResources" &&
        n.namespace_ () == "Common")
    {
      ::std::unique_ptr< ::Common::preloadResources > r (
        ::xsd::cxx::tree::traits< ::Common::preloadResources, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "preloadResources",
      "Common");
  }

  ::std::unique_ptr< ::Common::preloadResources >
  preloadResources_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "preloadResources" &&
        n.namespace_ () == "Common")
    {
      ::std::unique_ptr< ::Common::preloadResources > r (
        ::xsd::cxx::tree::traits< ::Common::preloadResources, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "preloadResources",
      "Common");
  }

  ::std::unique_ptr< ::Common::resources >
  resources_ (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::Common::resources > (
      ::Common::resources_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::resources >
  resources_ (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Common::resources > (
      ::Common::resources_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::resources >
  resources_ (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Common::resources > (
      ::Common::resources_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::resources >
  resources_ (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::Common::resources_ (isrc, f, p);
  }

  ::std::unique_ptr< ::Common::resources >
  resources_ (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::Common::resources_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Common::resources >
  resources_ (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::Common::resources_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Common::resources >
  resources_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::Common::resources_ (isrc, f, p);
  }

  ::std::unique_ptr< ::Common::resources >
  resources_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::Common::resources_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Common::resources >
  resources_ (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::Common::resources_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Common::resources >
  resources_ (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::Common::resources > (
      ::Common::resources_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::resources >
  resources_ (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Common::resources > (
      ::Common::resources_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::resources >
  resources_ (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Common::resources > (
      ::Common::resources_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::resources >
  resources_ (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::Common::resources > (
        ::Common::resources_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "resources" &&
        n.namespace_ () == "Common")
    {
      ::std::unique_ptr< ::Common::resources > r (
        ::xsd::cxx::tree::traits< ::Common::resources, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "resources",
      "Common");
  }

  ::std::unique_ptr< ::Common::resources >
  resources_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "resources" &&
        n.namespace_ () == "Common")
    {
      ::std::unique_ptr< ::Common::resources > r (
        ::xsd::cxx::tree::traits< ::Common::resources, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "resources",
      "Common");
  }

  ::std::unique_ptr< ::Common::events >
  events_ (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::Common::events > (
      ::Common::events_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::events >
  events_ (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Common::events > (
      ::Common::events_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::events >
  events_ (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Common::events > (
      ::Common::events_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::events >
  events_ (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::Common::events_ (isrc, f, p);
  }

  ::std::unique_ptr< ::Common::events >
  events_ (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::Common::events_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Common::events >
  events_ (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::Common::events_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Common::events >
  events_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::Common::events_ (isrc, f, p);
  }

  ::std::unique_ptr< ::Common::events >
  events_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::Common::events_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Common::events >
  events_ (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::Common::events_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Common::events >
  events_ (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::Common::events > (
      ::Common::events_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::events >
  events_ (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Common::events > (
      ::Common::events_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::events >
  events_ (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Common::events > (
      ::Common::events_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::events >
  events_ (const ::xercesc::DOMDocument& doc,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::Common::events > (
        ::Common::events_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "events" &&
        n.namespace_ () == "Common")
    {
      ::std::unique_ptr< ::Common::events > r (
        ::xsd::cxx::tree::traits< ::Common::events, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "events",
      "Common");
  }

  ::std::unique_ptr< ::Common::events >
  events_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "events" &&
        n.namespace_ () == "Common")
    {
      ::std::unique_ptr< ::Common::events > r (
        ::xsd::cxx::tree::traits< ::Common::events, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "events",
      "Common");
  }

  ::std::unique_ptr< ::Common::position >
  position_ (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::Common::position > (
      ::Common::position_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::position >
  position_ (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Common::position > (
      ::Common::position_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::position >
  position_ (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Common::position > (
      ::Common::position_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::position >
  position_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::Common::position_ (isrc, f, p);
  }

  ::std::unique_ptr< ::Common::position >
  position_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::Common::position_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Common::position >
  position_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::Common::position_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Common::position >
  position_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::Common::position_ (isrc, f, p);
  }

  ::std::unique_ptr< ::Common::position >
  position_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::Common::position_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Common::position >
  position_ (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::Common::position_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Common::position >
  position_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::Common::position > (
      ::Common::position_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::position >
  position_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Common::position > (
      ::Common::position_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::position >
  position_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Common::position > (
      ::Common::position_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::position >
  position_ (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::Common::position > (
        ::Common::position_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "position" &&
        n.namespace_ () == "Common")
    {
      ::std::unique_ptr< ::Common::position > r (
        ::xsd::cxx::tree::traits< ::Common::position, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "position",
      "Common");
  }

  ::std::unique_ptr< ::Common::position >
  position_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "position" &&
        n.namespace_ () == "Common")
    {
      ::std::unique_ptr< ::Common::position > r (
        ::xsd::cxx::tree::traits< ::Common::position, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "position",
      "Common");
  }

  ::std::unique_ptr< ::Common::size >
  size_ (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::Common::size > (
      ::Common::size_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::size >
  size_ (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Common::size > (
      ::Common::size_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::size >
  size_ (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Common::size > (
      ::Common::size_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::size >
  size_ (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::Common::size_ (isrc, f, p);
  }

  ::std::unique_ptr< ::Common::size >
  size_ (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::Common::size_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Common::size >
  size_ (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::Common::size_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Common::size >
  size_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::Common::size_ (isrc, f, p);
  }

  ::std::unique_ptr< ::Common::size >
  size_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::Common::size_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Common::size >
  size_ (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::Common::size_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Common::size >
  size_ (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::Common::size > (
      ::Common::size_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::size >
  size_ (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Common::size > (
      ::Common::size_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::size >
  size_ (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Common::size > (
      ::Common::size_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::size >
  size_ (const ::xercesc::DOMDocument& doc,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::Common::size > (
        ::Common::size_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "size" &&
        n.namespace_ () == "Common")
    {
      ::std::unique_ptr< ::Common::size > r (
        ::xsd::cxx::tree::traits< ::Common::size, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "size",
      "Common");
  }

  ::std::unique_ptr< ::Common::size >
  size_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "size" &&
        n.namespace_ () == "Common")
    {
      ::std::unique_ptr< ::Common::size > r (
        ::xsd::cxx::tree::traits< ::Common::size, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "size",
      "Common");
  }

  ::std::unique_ptr< ::Common::color >
  color_ (const ::std::string& u,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::Common::color > (
      ::Common::color_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::color >
  color_ (const ::std::string& u,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Common::color > (
      ::Common::color_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::color >
  color_ (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Common::color > (
      ::Common::color_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::color >
  color_ (::std::istream& is,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::Common::color_ (isrc, f, p);
  }

  ::std::unique_ptr< ::Common::color >
  color_ (::std::istream& is,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::Common::color_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Common::color >
  color_ (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::Common::color_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Common::color >
  color_ (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::Common::color_ (isrc, f, p);
  }

  ::std::unique_ptr< ::Common::color >
  color_ (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::Common::color_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Common::color >
  color_ (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::Common::color_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Common::color >
  color_ (::xercesc::InputSource& i,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::Common::color > (
      ::Common::color_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::color >
  color_ (::xercesc::InputSource& i,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Common::color > (
      ::Common::color_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::color >
  color_ (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Common::color > (
      ::Common::color_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::color >
  color_ (const ::xercesc::DOMDocument& doc,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::Common::color > (
        ::Common::color_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "color" &&
        n.namespace_ () == "Common")
    {
      ::std::unique_ptr< ::Common::color > r (
        ::xsd::cxx::tree::traits< ::Common::color, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "color",
      "Common");
  }

  ::std::unique_ptr< ::Common::color >
  color_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
          ::xml_schema::flags f,
          const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "color" &&
        n.namespace_ () == "Common")
    {
      ::std::unique_ptr< ::Common::color > r (
        ::xsd::cxx::tree::traits< ::Common::color, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "color",
      "Common");
  }

  ::std::unique_ptr< ::Common::font >
  font_ (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::Common::font > (
      ::Common::font_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::font >
  font_ (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Common::font > (
      ::Common::font_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::font >
  font_ (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Common::font > (
      ::Common::font_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::font >
  font_ (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::Common::font_ (isrc, f, p);
  }

  ::std::unique_ptr< ::Common::font >
  font_ (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::Common::font_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Common::font >
  font_ (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::Common::font_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Common::font >
  font_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::Common::font_ (isrc, f, p);
  }

  ::std::unique_ptr< ::Common::font >
  font_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::Common::font_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Common::font >
  font_ (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::Common::font_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Common::font >
  font_ (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::Common::font > (
      ::Common::font_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::font >
  font_ (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Common::font > (
      ::Common::font_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::font >
  font_ (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Common::font > (
      ::Common::font_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::font >
  font_ (const ::xercesc::DOMDocument& doc,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::Common::font > (
        ::Common::font_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "font" &&
        n.namespace_ () == "Common")
    {
      ::std::unique_ptr< ::Common::font > r (
        ::xsd::cxx::tree::traits< ::Common::font, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "font",
      "Common");
  }

  ::std::unique_ptr< ::Common::font >
  font_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "font" &&
        n.namespace_ () == "Common")
    {
      ::std::unique_ptr< ::Common::font > r (
        ::xsd::cxx::tree::traits< ::Common::font, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "font",
      "Common");
  }

  ::std::unique_ptr< ::Common::text_type >
  text_type_ (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::Common::text_type > (
      ::Common::text_type_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::text_type >
  text_type_ (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Common::text_type > (
      ::Common::text_type_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::text_type >
  text_type_ (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Common::text_type > (
      ::Common::text_type_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::text_type >
  text_type_ (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::Common::text_type_ (isrc, f, p);
  }

  ::std::unique_ptr< ::Common::text_type >
  text_type_ (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::Common::text_type_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Common::text_type >
  text_type_ (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::Common::text_type_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Common::text_type >
  text_type_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::Common::text_type_ (isrc, f, p);
  }

  ::std::unique_ptr< ::Common::text_type >
  text_type_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::Common::text_type_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Common::text_type >
  text_type_ (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::Common::text_type_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Common::text_type >
  text_type_ (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::Common::text_type > (
      ::Common::text_type_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::text_type >
  text_type_ (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Common::text_type > (
      ::Common::text_type_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::text_type >
  text_type_ (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Common::text_type > (
      ::Common::text_type_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Common::text_type >
  text_type_ (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::Common::text_type > (
        ::Common::text_type_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "text_type" &&
        n.namespace_ () == "Common")
    {
      ::std::unique_ptr< ::Common::text_type > r (
        ::xsd::cxx::tree::traits< ::Common::text_type, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "text_type",
      "Common");
  }

  ::std::unique_ptr< ::Common::text_type >
  text_type_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "text_type" &&
        n.namespace_ () == "Common")
    {
      ::std::unique_ptr< ::Common::text_type > r (
        ::xsd::cxx::tree::traits< ::Common::text_type, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "text_type",
      "Common");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.


// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "resources.hxx"

namespace GameResources
{
  // baseGameResource
  // 

  const baseGameResource::name_type& baseGameResource::
  name () const
  {
    return this->name_.get ();
  }

  baseGameResource::name_type& baseGameResource::
  name ()
  {
    return this->name_.get ();
  }

  void baseGameResource::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void baseGameResource::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const baseGameResource::path_type& baseGameResource::
  path () const
  {
    return this->path_.get ();
  }

  baseGameResource::path_type& baseGameResource::
  path ()
  {
    return this->path_.get ();
  }

  void baseGameResource::
  path (const path_type& x)
  {
    this->path_.set (x);
  }

  void baseGameResource::
  path (::std::unique_ptr< path_type > x)
  {
    this->path_.set (std::move (x));
  }


  // resources
  // 

  const resources::basePath_type& resources::
  basePath () const
  {
    return this->basePath_.get ();
  }

  resources::basePath_type& resources::
  basePath ()
  {
    return this->basePath_.get ();
  }

  void resources::
  basePath (const basePath_type& x)
  {
    this->basePath_.set (x);
  }

  void resources::
  basePath (::std::unique_ptr< basePath_type > x)
  {
    this->basePath_.set (std::move (x));
  }

  const resources::textures_type& resources::
  textures () const
  {
    return this->textures_.get ();
  }

  resources::textures_type& resources::
  textures ()
  {
    return this->textures_.get ();
  }

  void resources::
  textures (const textures_type& x)
  {
    this->textures_.set (x);
  }

  void resources::
  textures (::std::unique_ptr< textures_type > x)
  {
    this->textures_.set (std::move (x));
  }

  const resources::sprites_type& resources::
  sprites () const
  {
    return this->sprites_.get ();
  }

  resources::sprites_type& resources::
  sprites ()
  {
    return this->sprites_.get ();
  }

  void resources::
  sprites (const sprites_type& x)
  {
    this->sprites_.set (x);
  }

  void resources::
  sprites (::std::unique_ptr< sprites_type > x)
  {
    this->sprites_.set (std::move (x));
  }

  const resources::sounds_type& resources::
  sounds () const
  {
    return this->sounds_.get ();
  }

  resources::sounds_type& resources::
  sounds ()
  {
    return this->sounds_.get ();
  }

  void resources::
  sounds (const sounds_type& x)
  {
    this->sounds_.set (x);
  }

  void resources::
  sounds (::std::unique_ptr< sounds_type > x)
  {
    this->sounds_.set (std::move (x));
  }

  const resources::music_type& resources::
  music () const
  {
    return this->music_.get ();
  }

  resources::music_type& resources::
  music ()
  {
    return this->music_.get ();
  }

  void resources::
  music (const music_type& x)
  {
    this->music_.set (x);
  }

  void resources::
  music (::std::unique_ptr< music_type > x)
  {
    this->music_.set (std::move (x));
  }

  const resources::scenes_type& resources::
  scenes () const
  {
    return this->scenes_.get ();
  }

  resources::scenes_type& resources::
  scenes ()
  {
    return this->scenes_.get ();
  }

  void resources::
  scenes (const scenes_type& x)
  {
    this->scenes_.set (x);
  }

  void resources::
  scenes (::std::unique_ptr< scenes_type > x)
  {
    this->scenes_.set (std::move (x));
  }

  const resources::levels_type& resources::
  levels () const
  {
    return this->levels_.get ();
  }

  resources::levels_type& resources::
  levels ()
  {
    return this->levels_.get ();
  }

  void resources::
  levels (const levels_type& x)
  {
    this->levels_.set (x);
  }

  void resources::
  levels (::std::unique_ptr< levels_type > x)
  {
    this->levels_.set (std::move (x));
  }


  // textures
  // 

  const textures::texture_sequence& textures::
  texture () const
  {
    return this->texture_;
  }

  textures::texture_sequence& textures::
  texture ()
  {
    return this->texture_;
  }

  void textures::
  texture (const texture_sequence& s)
  {
    this->texture_ = s;
  }


  // sprites
  // 

  const sprites::sprite_sequence& sprites::
  sprite () const
  {
    return this->sprite_;
  }

  sprites::sprite_sequence& sprites::
  sprite ()
  {
    return this->sprite_;
  }

  void sprites::
  sprite (const sprite_sequence& s)
  {
    this->sprite_ = s;
  }


  // sounds
  // 

  const sounds::sound_sequence& sounds::
  sound () const
  {
    return this->sound_;
  }

  sounds::sound_sequence& sounds::
  sound ()
  {
    return this->sound_;
  }

  void sounds::
  sound (const sound_sequence& s)
  {
    this->sound_ = s;
  }


  // music
  // 

  const music::music1_sequence& music::
  music1 () const
  {
    return this->music1_;
  }

  music::music1_sequence& music::
  music1 ()
  {
    return this->music1_;
  }

  void music::
  music1 (const music1_sequence& s)
  {
    this->music1_ = s;
  }


  // scenes
  // 

  const scenes::scene_sequence& scenes::
  scene () const
  {
    return this->scene_;
  }

  scenes::scene_sequence& scenes::
  scene ()
  {
    return this->scene_;
  }

  void scenes::
  scene (const scene_sequence& s)
  {
    this->scene_ = s;
  }


  // levels
  // 

  const levels::level_sequence& levels::
  level () const
  {
    return this->level_;
  }

  levels::level_sequence& levels::
  level ()
  {
    return this->level_;
  }

  void levels::
  level (const level_sequence& s)
  {
    this->level_ = s;
  }


  // texture
  // 


  // sprite
  // 

  const sprite::definition_optional& sprite::
  definition () const
  {
    return this->definition_;
  }

  sprite::definition_optional& sprite::
  definition ()
  {
    return this->definition_;
  }

  void sprite::
  definition (const definition_type& x)
  {
    this->definition_.set (x);
  }

  void sprite::
  definition (const definition_optional& x)
  {
    this->definition_ = x;
  }

  void sprite::
  definition (::std::unique_ptr< definition_type > x)
  {
    this->definition_.set (std::move (x));
  }

  const sprite::size_optional& sprite::
  size () const
  {
    return this->size_;
  }

  sprite::size_optional& sprite::
  size ()
  {
    return this->size_;
  }

  void sprite::
  size (const size_type& x)
  {
    this->size_.set (x);
  }

  void sprite::
  size (const size_optional& x)
  {
    this->size_ = x;
  }

  void sprite::
  size (::std::unique_ptr< size_type > x)
  {
    this->size_.set (std::move (x));
  }


  // sound
  // 


  // music1
  // 


  // scene
  // 


  // level
  // 

  const level::spriteName_type& level::
  spriteName () const
  {
    return this->spriteName_.get ();
  }

  level::spriteName_type& level::
  spriteName ()
  {
    return this->spriteName_.get ();
  }

  void level::
  spriteName (const spriteName_type& x)
  {
    this->spriteName_.set (x);
  }

  void level::
  spriteName (::std::unique_ptr< spriteName_type > x)
  {
    this->spriteName_.set (std::move (x));
  }

  const level::spriteSheetPath_type& level::
  spriteSheetPath () const
  {
    return this->spriteSheetPath_.get ();
  }

  level::spriteSheetPath_type& level::
  spriteSheetPath ()
  {
    return this->spriteSheetPath_.get ();
  }

  void level::
  spriteSheetPath (const spriteSheetPath_type& x)
  {
    this->spriteSheetPath_.set (x);
  }

  void level::
  spriteSheetPath (::std::unique_ptr< spriteSheetPath_type > x)
  {
    this->spriteSheetPath_.set (std::move (x));
  }

  const level::tmxPath_type& level::
  tmxPath () const
  {
    return this->tmxPath_.get ();
  }

  level::tmxPath_type& level::
  tmxPath ()
  {
    return this->tmxPath_.get ();
  }

  void level::
  tmxPath (const tmxPath_type& x)
  {
    this->tmxPath_.set (x);
  }

  void level::
  tmxPath (::std::unique_ptr< tmxPath_type > x)
  {
    this->tmxPath_.set (std::move (x));
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace GameResources
{
  // baseGameResource
  //

  baseGameResource::
  baseGameResource (const name_type& name,
                    const path_type& path)
  : ::xml_schema::type (),
    name_ (name, this),
    path_ (path, this)
  {
  }

  baseGameResource::
  baseGameResource (const baseGameResource& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    path_ (x.path_, f, this)
  {
  }

  baseGameResource::
  baseGameResource (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (this),
    path_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void baseGameResource::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        if (!name_.present ())
        {
          this->name_.set (::std::move (r));
          continue;
        }
      }

      // path
      //
      if (n.name () == "path" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< path_type > r (
          path_traits::create (i, f, this));

        if (!path_.present ())
        {
          this->path_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name",
        "");
    }

    if (!path_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "path",
        "");
    }
  }

  baseGameResource* baseGameResource::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class baseGameResource (*this, f, c);
  }

  baseGameResource& baseGameResource::
  operator= (const baseGameResource& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->name_ = x.name_;
      this->path_ = x.path_;
    }

    return *this;
  }

  baseGameResource::
  ~baseGameResource ()
  {
  }

  // resources
  //

  resources::
  resources (const basePath_type& basePath,
             const textures_type& textures,
             const sprites_type& sprites,
             const sounds_type& sounds,
             const music_type& music,
             const scenes_type& scenes,
             const levels_type& levels)
  : ::xml_schema::type (),
    basePath_ (basePath, this),
    textures_ (textures, this),
    sprites_ (sprites, this),
    sounds_ (sounds, this),
    music_ (music, this),
    scenes_ (scenes, this),
    levels_ (levels, this)
  {
  }

  resources::
  resources (const basePath_type& basePath,
             ::std::unique_ptr< textures_type > textures,
             ::std::unique_ptr< sprites_type > sprites,
             ::std::unique_ptr< sounds_type > sounds,
             ::std::unique_ptr< music_type > music,
             ::std::unique_ptr< scenes_type > scenes,
             ::std::unique_ptr< levels_type > levels)
  : ::xml_schema::type (),
    basePath_ (basePath, this),
    textures_ (std::move (textures), this),
    sprites_ (std::move (sprites), this),
    sounds_ (std::move (sounds), this),
    music_ (std::move (music), this),
    scenes_ (std::move (scenes), this),
    levels_ (std::move (levels), this)
  {
  }

  resources::
  resources (const resources& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    basePath_ (x.basePath_, f, this),
    textures_ (x.textures_, f, this),
    sprites_ (x.sprites_, f, this),
    sounds_ (x.sounds_, f, this),
    music_ (x.music_, f, this),
    scenes_ (x.scenes_, f, this),
    levels_ (x.levels_, f, this)
  {
  }

  resources::
  resources (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    basePath_ (this),
    textures_ (this),
    sprites_ (this),
    sounds_ (this),
    music_ (this),
    scenes_ (this),
    levels_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void resources::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // basePath
      //
      if (n.name () == "basePath" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< basePath_type > r (
          basePath_traits::create (i, f, this));

        if (!basePath_.present ())
        {
          this->basePath_.set (::std::move (r));
          continue;
        }
      }

      // textures
      //
      if (n.name () == "textures" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< textures_type > r (
          textures_traits::create (i, f, this));

        if (!textures_.present ())
        {
          this->textures_.set (::std::move (r));
          continue;
        }
      }

      // sprites
      //
      if (n.name () == "sprites" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< sprites_type > r (
          sprites_traits::create (i, f, this));

        if (!sprites_.present ())
        {
          this->sprites_.set (::std::move (r));
          continue;
        }
      }

      // sounds
      //
      if (n.name () == "sounds" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< sounds_type > r (
          sounds_traits::create (i, f, this));

        if (!sounds_.present ())
        {
          this->sounds_.set (::std::move (r));
          continue;
        }
      }

      // music
      //
      if (n.name () == "music" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< music_type > r (
          music_traits::create (i, f, this));

        if (!music_.present ())
        {
          this->music_.set (::std::move (r));
          continue;
        }
      }

      // scenes
      //
      if (n.name () == "scenes" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< scenes_type > r (
          scenes_traits::create (i, f, this));

        if (!scenes_.present ())
        {
          this->scenes_.set (::std::move (r));
          continue;
        }
      }

      // levels
      //
      if (n.name () == "levels" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< levels_type > r (
          levels_traits::create (i, f, this));

        if (!levels_.present ())
        {
          this->levels_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!basePath_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "basePath",
        "");
    }

    if (!textures_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "textures",
        "");
    }

    if (!sprites_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "sprites",
        "");
    }

    if (!sounds_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "sounds",
        "");
    }

    if (!music_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "music",
        "");
    }

    if (!scenes_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "scenes",
        "");
    }

    if (!levels_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "levels",
        "");
    }
  }

  resources* resources::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class resources (*this, f, c);
  }

  resources& resources::
  operator= (const resources& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->basePath_ = x.basePath_;
      this->textures_ = x.textures_;
      this->sprites_ = x.sprites_;
      this->sounds_ = x.sounds_;
      this->music_ = x.music_;
      this->scenes_ = x.scenes_;
      this->levels_ = x.levels_;
    }

    return *this;
  }

  resources::
  ~resources ()
  {
  }

  // textures
  //

  textures::
  textures ()
  : ::xml_schema::type (),
    texture_ (this)
  {
  }

  textures::
  textures (const textures& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    texture_ (x.texture_, f, this)
  {
  }

  textures::
  textures (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    texture_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void textures::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // texture
      //
      if (n.name () == "texture" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< texture_type > r (
          texture_traits::create (i, f, this));

        this->texture_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  textures* textures::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class textures (*this, f, c);
  }

  textures& textures::
  operator= (const textures& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->texture_ = x.texture_;
    }

    return *this;
  }

  textures::
  ~textures ()
  {
  }

  // sprites
  //

  sprites::
  sprites ()
  : ::xml_schema::type (),
    sprite_ (this)
  {
  }

  sprites::
  sprites (const sprites& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    sprite_ (x.sprite_, f, this)
  {
  }

  sprites::
  sprites (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    sprite_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void sprites::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // sprite
      //
      if (n.name () == "sprite" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< sprite_type > r (
          sprite_traits::create (i, f, this));

        this->sprite_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  sprites* sprites::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class sprites (*this, f, c);
  }

  sprites& sprites::
  operator= (const sprites& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->sprite_ = x.sprite_;
    }

    return *this;
  }

  sprites::
  ~sprites ()
  {
  }

  // sounds
  //

  sounds::
  sounds ()
  : ::xml_schema::type (),
    sound_ (this)
  {
  }

  sounds::
  sounds (const sounds& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    sound_ (x.sound_, f, this)
  {
  }

  sounds::
  sounds (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    sound_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void sounds::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // sound
      //
      if (n.name () == "sound" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< sound_type > r (
          sound_traits::create (i, f, this));

        this->sound_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  sounds* sounds::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class sounds (*this, f, c);
  }

  sounds& sounds::
  operator= (const sounds& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->sound_ = x.sound_;
    }

    return *this;
  }

  sounds::
  ~sounds ()
  {
  }

  // music
  //

  music::
  music ()
  : ::xml_schema::type (),
    music1_ (this)
  {
  }

  music::
  music (const music& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    music1_ (x.music1_, f, this)
  {
  }

  music::
  music (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    music1_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void music::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // music
      //
      if (n.name () == "music" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< music1_type > r (
          music1_traits::create (i, f, this));

        this->music1_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  music* music::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class music (*this, f, c);
  }

  music& music::
  operator= (const music& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->music1_ = x.music1_;
    }

    return *this;
  }

  music::
  ~music ()
  {
  }

  // scenes
  //

  scenes::
  scenes ()
  : ::xml_schema::type (),
    scene_ (this)
  {
  }

  scenes::
  scenes (const scenes& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    scene_ (x.scene_, f, this)
  {
  }

  scenes::
  scenes (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    scene_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void scenes::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // scene
      //
      if (n.name () == "scene" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< scene_type > r (
          scene_traits::create (i, f, this));

        this->scene_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  scenes* scenes::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class scenes (*this, f, c);
  }

  scenes& scenes::
  operator= (const scenes& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->scene_ = x.scene_;
    }

    return *this;
  }

  scenes::
  ~scenes ()
  {
  }

  // levels
  //

  levels::
  levels ()
  : ::xml_schema::type (),
    level_ (this)
  {
  }

  levels::
  levels (const levels& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    level_ (x.level_, f, this)
  {
  }

  levels::
  levels (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    level_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void levels::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // level
      //
      if (n.name () == "level" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< level_type > r (
          level_traits::create (i, f, this));

        this->level_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  levels* levels::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class levels (*this, f, c);
  }

  levels& levels::
  operator= (const levels& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->level_ = x.level_;
    }

    return *this;
  }

  levels::
  ~levels ()
  {
  }

  // texture
  //

  texture::
  texture (const name_type& name,
           const path_type& path)
  : ::GameResources::baseGameResource (name,
                                       path)
  {
  }

  texture::
  texture (const texture& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::GameResources::baseGameResource (x, f, c)
  {
  }

  texture::
  texture (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::GameResources::baseGameResource (e, f, c)
  {
  }

  texture* texture::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class texture (*this, f, c);
  }

  texture::
  ~texture ()
  {
  }

  // sprite
  //

  sprite::
  sprite (const name_type& name,
          const path_type& path)
  : ::GameResources::baseGameResource (name,
                                       path),
    definition_ (this),
    size_ (this)
  {
  }

  sprite::
  sprite (const sprite& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::GameResources::baseGameResource (x, f, c),
    definition_ (x.definition_, f, this),
    size_ (x.size_, f, this)
  {
  }

  sprite::
  sprite (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::GameResources::baseGameResource (e, f | ::xml_schema::flags::base, c),
    definition_ (this),
    size_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void sprite::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::GameResources::baseGameResource::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // definition
      //
      if (n.name () == "definition" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< definition_type > r (
          definition_traits::create (i, f, this));

        if (!this->definition_)
        {
          this->definition_.set (::std::move (r));
          continue;
        }
      }

      // size
      //
      if (n.name () == "size" && n.namespace_ () == "Common")
      {
        ::std::unique_ptr< size_type > r (
          size_traits::create (i, f, this));

        if (!this->size_)
        {
          this->size_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  sprite* sprite::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class sprite (*this, f, c);
  }

  sprite& sprite::
  operator= (const sprite& x)
  {
    if (this != &x)
    {
      static_cast< ::GameResources::baseGameResource& > (*this) = x;
      this->definition_ = x.definition_;
      this->size_ = x.size_;
    }

    return *this;
  }

  sprite::
  ~sprite ()
  {
  }

  // sound
  //

  sound::
  sound (const name_type& name,
         const path_type& path)
  : ::GameResources::baseGameResource (name,
                                       path)
  {
  }

  sound::
  sound (const sound& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::GameResources::baseGameResource (x, f, c)
  {
  }

  sound::
  sound (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::GameResources::baseGameResource (e, f, c)
  {
  }

  sound* sound::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class sound (*this, f, c);
  }

  sound::
  ~sound ()
  {
  }

  // music1
  //

  music1::
  music1 (const name_type& name,
          const path_type& path)
  : ::GameResources::baseGameResource (name,
                                       path)
  {
  }

  music1::
  music1 (const music1& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::GameResources::baseGameResource (x, f, c)
  {
  }

  music1::
  music1 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::GameResources::baseGameResource (e, f, c)
  {
  }

  music1* music1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class music1 (*this, f, c);
  }

  music1::
  ~music1 ()
  {
  }

  // scene
  //

  scene::
  scene (const name_type& name,
         const path_type& path)
  : ::GameResources::baseGameResource (name,
                                       path)
  {
  }

  scene::
  scene (const scene& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::GameResources::baseGameResource (x, f, c)
  {
  }

  scene::
  scene (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::GameResources::baseGameResource (e, f, c)
  {
  }

  scene* scene::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class scene (*this, f, c);
  }

  scene::
  ~scene ()
  {
  }

  // level
  //

  level::
  level (const name_type& name,
         const path_type& path,
         const spriteName_type& spriteName,
         const spriteSheetPath_type& spriteSheetPath,
         const tmxPath_type& tmxPath)
  : ::GameResources::baseGameResource (name,
                                       path),
    spriteName_ (spriteName, this),
    spriteSheetPath_ (spriteSheetPath, this),
    tmxPath_ (tmxPath, this)
  {
  }

  level::
  level (const level& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::GameResources::baseGameResource (x, f, c),
    spriteName_ (x.spriteName_, f, this),
    spriteSheetPath_ (x.spriteSheetPath_, f, this),
    tmxPath_ (x.tmxPath_, f, this)
  {
  }

  level::
  level (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::GameResources::baseGameResource (e, f | ::xml_schema::flags::base, c),
    spriteName_ (this),
    spriteSheetPath_ (this),
    tmxPath_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void level::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::GameResources::baseGameResource::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // spriteName
      //
      if (n.name () == "spriteName" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< spriteName_type > r (
          spriteName_traits::create (i, f, this));

        if (!spriteName_.present ())
        {
          this->spriteName_.set (::std::move (r));
          continue;
        }
      }

      // spriteSheetPath
      //
      if (n.name () == "spriteSheetPath" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< spriteSheetPath_type > r (
          spriteSheetPath_traits::create (i, f, this));

        if (!spriteSheetPath_.present ())
        {
          this->spriteSheetPath_.set (::std::move (r));
          continue;
        }
      }

      // tmxPath
      //
      if (n.name () == "tmxPath" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< tmxPath_type > r (
          tmxPath_traits::create (i, f, this));

        if (!tmxPath_.present ())
        {
          this->tmxPath_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!spriteName_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "spriteName",
        "");
    }

    if (!spriteSheetPath_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "spriteSheetPath",
        "");
    }

    if (!tmxPath_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "tmxPath",
        "");
    }
  }

  level* level::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class level (*this, f, c);
  }

  level& level::
  operator= (const level& x)
  {
    if (this != &x)
    {
      static_cast< ::GameResources::baseGameResource& > (*this) = x;
      this->spriteName_ = x.spriteName_;
      this->spriteSheetPath_ = x.spriteSheetPath_;
      this->tmxPath_ = x.tmxPath_;
    }

    return *this;
  }

  level::
  ~level ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace GameResources
{
  ::std::unique_ptr< ::GameResources::resources >
  resources_ (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::GameResources::resources > (
      ::GameResources::resources_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::GameResources::resources >
  resources_ (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::GameResources::resources > (
      ::GameResources::resources_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::GameResources::resources >
  resources_ (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::GameResources::resources > (
      ::GameResources::resources_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::GameResources::resources >
  resources_ (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::GameResources::resources_ (isrc, f, p);
  }

  ::std::unique_ptr< ::GameResources::resources >
  resources_ (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::GameResources::resources_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::GameResources::resources >
  resources_ (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::GameResources::resources_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::GameResources::resources >
  resources_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::GameResources::resources_ (isrc, f, p);
  }

  ::std::unique_ptr< ::GameResources::resources >
  resources_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::GameResources::resources_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::GameResources::resources >
  resources_ (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::GameResources::resources_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::GameResources::resources >
  resources_ (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::GameResources::resources > (
      ::GameResources::resources_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::GameResources::resources >
  resources_ (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::GameResources::resources > (
      ::GameResources::resources_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::GameResources::resources >
  resources_ (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::GameResources::resources > (
      ::GameResources::resources_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::GameResources::resources >
  resources_ (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::GameResources::resources > (
        ::GameResources::resources_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "resources" &&
        n.namespace_ () == "GameResources")
    {
      ::std::unique_ptr< ::GameResources::resources > r (
        ::xsd::cxx::tree::traits< ::GameResources::resources, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "resources",
      "GameResources");
  }

  ::std::unique_ptr< ::GameResources::resources >
  resources_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "resources" &&
        n.namespace_ () == "GameResources")
    {
      ::std::unique_ptr< ::GameResources::resources > r (
        ::xsd::cxx::tree::traits< ::GameResources::resources, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "resources",
      "GameResources");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

